<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gridWorld - Digital Art Gallery</title>
    
    <!-- Framer Motion for smooth animations -->
    <script src="https://cdn.jsdelivr.net/npm/framer-motion@10.17.0/dist/framer-motion.js"></script>
    
    <!-- Waveform visualization for audio -->
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.4.0/dist/wavesurfer.min.js"></script>
    
    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body, html {
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
        }
        
        .gallery-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        .gallery {
            display: flex;
            width: 100%;
            height: 100%;
            transition: transform 0.5s ease-in-out;
        }
        
        .media-item {
            min-width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            opacity: 1;
            transition: opacity 0.25s ease-in-out;
        }
        
        .media-content {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Image styles */
        .media-content img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        /* Video styles */
        .media-content video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        /* Text/Markdown content styles with variations */
        .text-content {
            width: 80%;
            max-width: 800px;
            padding: 2rem;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-height: 90%;
            overflow-y: auto;
        }
        
        /* Base text content styles */
        .text-content {
            width: 80%;
            max-width: 800px;
            padding: 2rem;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-height: 90%;
            overflow-y: auto;
        }
        
        /* Zine-style variations - Season 1 */
        .text-content.zine-style-1 {
            font-family: 'Courier New', monospace;
            background: rgba(40, 35, 30, 0.9);
            border: 2px solid #d4af37;
        }
        
        .text-content.zine-style-2 {
            font-family: 'Georgia', serif;
            background: rgba(20, 30, 40, 0.9);
            border: 2px dashed #6c63ff;
        }
        
        .text-content.zine-style-3 {
            font-family: 'Helvetica', sans-serif;
            background: rgba(30, 20, 40, 0.9);
            border: 3px double #ff6b6b;
        }
        
        .text-content.zine-style-4 {
            font-family: 'Comic Sans MS', cursive;
            background: rgba(30, 30, 30, 0.95);
            border: 4px ridge #4ecdc4;
        }
        
        .text-content.zine-style-5 {
            font-family: 'Times New Roman', serif;
            background: rgba(40, 25, 25, 0.9);
            border: 2px outset #f0a0a0;
        }
        
        /* Season 2 - Alternative layouts */
        .text-content.season-2.zine-style-1 {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 3rem;
        }
        
        .text-content.season-2.zine-style-2 {
            font-family: 'Verdana', sans-serif;
            background: rgba(0, 0, 0, 0.7);
            border-left: 8px solid #00ff00;
            border-right: 8px solid #00ff00;
        }
        
        .text-content.season-2.zine-style-3 {
            font-family: 'Impact', sans-serif;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23222" opacity="0.2"/><path d="M0 50 L100 50 M50 0 L50 100" stroke="%23444" stroke-width="1"/></svg>');
            border: 4px groove #ff69b4;
        }
        
        .text-content.season-2.zine-style-4 {
            font-family: 'Brush Script MT', cursive;
            background: rgba(255, 248, 220, 0.2);
            border: 5px double #8b4513;
        }
        
        .text-content.season-2.zine-style-5 {
            font-family: 'Monaco', monospace;
            background: rgba(0, 0, 0, 0.9);
            border: 2px inset #444;
            box-shadow: inset 0 0 20px rgba(0, 100, 0, 0.5);
        }
        
        /* Season 3 - Alternative layouts */
        .text-content.season-3.zine-style-1 {
            font-family: 'Palatino', serif;
            background: rgba(50, 25, 75, 0.85);
            border: 3px outset #9370db;
            border-radius: 15px;
        }
        
        .text-content.season-3.zine-style-2 {
            font-family: 'Trebuchet MS', sans-serif;
            background: rgba(139, 0, 0, 0.2);
            border: 6px ridge #ff4500;
        }
        
        .text-content.season-3.zine-style-3 {
            font-family: 'Garamond', serif;
            background: rgba(255, 250, 205, 0.1);
            border: 2px solid #daa520;
            border-style: double;
        }
        
        .text-content.season-3.zine-style-4 {
            font-family: 'Lucida Console', monospace;
            background: rgba(0, 0, 0, 0.8);
            border: 3px inset #00ffff;
        }
        
        .text-content.season-3.zine-style-5 {
            font-family: 'Copperplate', cursive;
            background: rgba(40, 44, 52, 0.95);
            border: 4px outset #ff6347;
        }
        
        /* Season 4 - Alternative layouts */
        .text-content.season-4.zine-style-1 {
            font-family: 'Book Antiqua', serif;
            background: rgba(25, 25, 112, 0.7);
            border: 2px solid #8a2be2;
            border-radius: 25px;
        }
        
        .text-content.season-4.zine-style-2 {
            font-family: 'Optima', sans-serif;
            background: rgba(25, 50, 25, 0.6);
            border: 5px double #32cd32;
        }
        
        .text-content.season-4.zine-style-3 {
            font-family: 'Lucida Sans Unicode', sans-serif;
            background: rgba(70, 130, 180, 0.2);
            border: 3px ridge #4682b4;
        }
        
        .text-content.season-4.zine-style-4 {
            font-family: 'Papyrus', fantasy;
            background: rgba(245, 222, 179, 0.15);
            border: 4px solid #8b4513;
        }
        
        .text-content.season-4.zine-style-5 {
            font-family: 'Century Gothic', sans-serif;
            background: rgba(0, 0, 0, 0.7);
            border: 2px inset #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        /* Season 5 - Additional layouts */
        .text-content.season-5.zine-style-1 {
            font-family: 'Georgia', serif;
            background: linear-gradient(45deg, #2c3e50, #34495e, #2c3e50);
            border: 1px solid #ecf0f1;
            border-left: 10px solid #3498db;
            border-right: 10px solid #9b59b6;
            padding: 2.5rem;
            font-size: 1.2rem;
            line-height: 1.8;
        }
        
        .text-content.season-5.zine-style-2 {
            font-family: 'Trebuchet MS', sans-serif;
            background: rgba(0, 0, 0, 0.85);
            border: 3px double #f1c40f;
            color: #f1c40f;
            text-shadow: 0 0 5px rgba(241, 196, 15, 0.5);
            padding: 2rem;
        }
        
        .text-content.season-5.zine-style-3 {
            font-family: 'Courier New', monospace;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #7f8c8d;
            border-top: 5px solid #3498db;
            border-bottom: 5px solid #e74c3c;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        .text-content.season-5.zine-style-4 {
            font-family: 'Impact', sans-serif;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23000000" opacity="0.9"/><path d="M0,0 L100,100 M100,0 L0,100" stroke="%23444" stroke-width="1"/></svg>');
            border: 4px dashed #e67e22;
            color: white;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .text-content.season-5.zine-style-5 {
            font-family: 'Comic Sans MS', cursive;
            background: linear-gradient(135deg, #ff9a9e, #fad0c4);
            color: #2c3e50;
            border: 3px ridge #e74c3c;
            border-radius: 15px;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* Season 6 - Additional layouts */
        .text-content.season-6.zine-style-1 {
            font-family: 'Palatino', serif;
            background: rgba(245, 245, 220, 0.9);
            border: 2px solid #8b4513;
            border-left: 8px solid #8b4513;
            color: #2c3e50;
            font-style: italic;
        }
        
        .text-content.season-6.zine-style-2 {
            font-family: 'Arial Black', sans-serif;
            background: #000;
            color: #fff;
            border: 1px solid #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
            line-height: 1.4;
        }
        
        .text-content.season-6.zine-style-3 {
            font-family: 'Lucida Console', monospace;
            background: #002b36;
            color: #859900;
            border: 1px solid #859900;
            font-size: 1rem;
            line-height: 1.7;
        }
        
        .text-content.season-6.zine-style-4 {
            font-family: 'Brush Script MT', cursive;
            background: linear-gradient(45deg, #d7bde2, #e6b0aa, #d7bde2);
            color: #2c3e50;
            text-align: center;
            padding: 3rem;
            border-radius: 50%;
        }
        
        .text-content.season-6.zine-style-5 {
            font-family: 'Helvetica Neue', sans-serif;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        
        /* Text Categories - Full Page Maximalist */
        .text-content.category-maximalist {
            width: 90%;
            height: 90%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .text-content.category-maximalist h1 {
            font-size: 3rem;
            line-height: 1.2;
            margin: 0;
        }
        
        /* Text Categories - Aphorisms/Ramblings */
        .text-content.category-aphorisms {
            width: 85%;
            padding: 1.5rem;
            display: block;
        }
        
        .text-content.category-aphorisms .aphorism-entry {
            margin: 1.5rem 0;
            padding: 1rem;
            border-bottom: 1px dotted #666;
        }
        
        .text-content.category-aphorisms .aphorism-entry.aphorism-left {
            text-align: left;
            border-left: 3px solid #ff6b6b;
            margin-right: 20%;
            padding-left: 1.5rem;
        }
        
        .text-content.category-aphorisms .aphorism-entry.aphorism-right {
            text-align: right;
            border-right: 3px solid #6c63ff;
            margin-left: 20%;
            padding-right: 1.5rem;
        }
        
        /* Fallback for nth-child in case JavaScript doesn't add classes */
        .text-content.category-aphorisms .aphorism-entry:nth-child(odd) {
            text-align: right;
            border-right: 3px solid #6c63ff;
            margin-left: 20%;
            padding-right: 1.5rem;
        }
        
        .text-content.category-aphorisms .aphorism-entry:nth-child(even) {
            text-align: left;
            border-left: 3px solid #ff6b6b;
            margin-right: 20%;
            padding-left: 1.5rem;
        }
        
        /* Text Categories - Articles */
        .text-content.category-article {
            width: 70%;
            padding: 2.5rem;
            text-align: left;
            font-family: 'Georgia', 'Times New Roman', serif;
            line-height: 1.8;
            font-size: 1.1rem;
        }
        
        .text-content.category-article h1 {
            text-align: center;
            margin: 0 0 1.5rem 0;
            font-size: 2.2rem;
            font-weight: bold;
            color: #f0f0f0;
        }
        
        .text-content.category-article h2 {
            margin: 2rem 0 1rem 0;
            font-size: 1.6rem;
            font-weight: bold;
            color: #6c63ff;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
        }
        
        .text-content.category-article h3 {
            margin: 1.5rem 0 0.8rem 0;
            font-size: 1.3rem;
            font-weight: bold;
            color: #ff6b6b;
        }
        
        .text-content.category-article p {
            margin: 1.2rem 0;
            text-align: justify;
            line-height: 1.8;
        }
        
        .text-content.category-article blockquote {
            margin: 2rem 0;
            padding: 1rem 1.5rem;
            border-left: 4px solid #6c63ff;
            background-color: rgba(0, 0, 0, 0.2);
            font-style: italic;
            color: #ccc;
        }
        
        .text-content.category-article .article-image {
            margin: 2rem auto;
            display: block;
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
        
        .text-content.category-article .caption {
            text-align: center;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 0.5rem;
            font-style: italic;
        }
        
        .text-content.category-article .byline {
            text-align: center;
            margin: 1rem 0 2rem 0;
            font-style: italic;
            color: #888;
        }
        
        /* Text Categories - Magazine Articles */
        .text-content.category-magazine {
            width: 80%;
            padding: 2rem;
            text-align: left;
            font-family: 'Merriweather', 'Georgia', serif;
            line-height: 1.7;
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid #555;
        }
        
        .text-content.category-magazine h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .text-content.category-magazine .subtitle {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 2rem;
            color: #aaa;
            font-style: italic;
        }
        
        .text-content.category-magazine .author {
            text-align: center;
            font-size: 1rem;
            margin-bottom: 2rem;
            color: #888;
        }
        
        .text-content.category-magazine .section-title {
            font-size: 1.4rem;
            color: #ff6b6b;
            margin: 1.5rem 0 1rem 0;
            text-transform: uppercase;
            border-bottom: 1px solid #666;
            padding-bottom: 0.3rem;
        }
        
        .text-content.category-magazine .pull-quote {
            margin: 1.5rem 0;
            padding: 1rem 2rem;
            font-size: 1.3rem;
            font-style: italic;
            color: #ffd700;
            border-left: 4px solid #ffd700;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .text-content.category-magazine .mag-content {
            display: flex;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .text-content.category-magazine .mag-text {
            flex: 3;
        }
        
        .text-content.category-magazine .mag-aside {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 5px;
        }
        
        /* Text Categories - Poems */
        .text-content.category-poem {
            width: 75%;
            padding: 2rem;
            text-align: center;
        }
        
        .text-content.category-poem .poem-lines {
            line-height: 2;
            margin: 1.5rem 0;
        }
        
        .text-content.category-poem .poem-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            font-style: italic;
        }
        
        /* Text Categories - Captions */
        .text-content.category-caption {
            width: 60%;
            padding: 1rem;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .text-content.category-caption p {
            font-style: italic;
            opacity: 0.8;
        }
        
        /* Season-specific variations for each category */
        .text-content.season-1.category-maximalist h1 { font-size: 3.5rem; }
        .text-content.season-2.category-maximalist h1 { font-size: 3rem; text-shadow: 2px 2px 4px rgba(255,255,255,0.5); }
        .text-content.season-3.category-maximalist h1 { font-size: 4rem; letter-spacing: 3px; }
        .text-content.season-4.category-maximalist h1 { font-size: 2.8rem; text-transform: uppercase; }
        
        .text-content.season-1.category-aphorisms .aphorism-entry:nth-child(odd) { margin-left: 10%; }
        .text-content.season-1.category-aphorisms .aphorism-entry:nth-child(even) { margin-right: 10%; }
        .text-content.season-3.category-aphorisms .aphorism-entry:nth-child(odd) { border-right: 5px solid #9370db; }
        .text-content.season-4.category-aphorisms .aphorism-entry:nth-child(even) { border-left: 5px double #00ffff; }
        
        .text-content h1, .text-content h2, .text-content h3 {
            margin: 1rem 0;
            color: #f0f0f0;
        }
        
        .text-content.zine-style-1 h1, .text-content.zine-style-1 h2, .text-content.zine-style-1 h3 {
            color: #d4af37;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .text-content.zine-style-2 h1, .text-content.zine-style-2 h2, .text-content.zine-style-2 h3 {
            color: #6c63ff;
            font-style: italic;
        }
        
        .text-content.zine-style-3 h1, .text-content.zine-style-3 h2, .text-content.zine-style-3 h3 {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .text-content.zine-style-4 h1, .text-content.zine-style-4 h2, .text-content.zine-style-4 h3 {
            color: #4ecdc4;
            font-weight: 800;
        }
        
        .text-content.zine-style-5 h1, .text-content.zine-style-5 h2, .text-content.zine-style-5 h3 {
            color: #f0a0a0;
            font-variant: small-caps;
        }
        
        .text-content p {
            margin: 1rem 0;
            line-height: 1.6;
            font-size: 1.1rem;
        }
        
        .text-content pre {
            background: #2d2d2d;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
        }
        
        .text-content code {
            font-family: 'Courier New', monospace;
            background: #2d2d2d;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
        }
        
        .text-content blockquote {
            border-left: 4px solid #6c63ff;
            padding-left: 1rem;
            margin: 1rem 0;
            font-style: italic;
            color: #ccc;
        }
        
        /* Audio visualization styles */
        .audio-content {
            width: 80%;
            max-width: 800px;
            padding: 2rem;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .audio-visualization {
            width: 100%;
            height: 200px;
            margin: 2rem 0;
        }
        
        .audio-info {
            text-align: center;
            margin-top: 1rem;
        }
        
        .audio-info h3 {
            margin-bottom: 0.5rem;
        }
        
        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            z-index: 50;
        }
        
        /* Swipe hint */
        .swipe-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="gallery-container">
        <div class="gallery" id="gallery">
            <!-- Media items will be loaded here -->
        </div>
        
        <div class="swipe-hint">← Swipe or use arrow keys →</div>
        
        <div class="loading" id="loading">Loading gallery...</div>
    </div>

    <script>
        // Environment variables - in a real app, this would be loaded from the server
        // For this demo, we'll load from a secure backend endpoint
        let env = {};
        
        // Initialize environment from secure server endpoint
        async function initializeEnvironment() {
            try {
                // In a real implementation, this would call your backend
                // which securely manages the credentials
                const response = await fetch('/api/gallery-env', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${getAuthToken()}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    env = await response.json();
                } else {
                    // Fallback to default values if server call fails
                    env = {
                        DIGITAL_OCEAN_ENABLED: false,
                        DIGITAL_OCEAN_ENDPOINT: 'https://your-space-name.sfo3.digitaloceanspaces.com',
                        DIGITAL_OCEAN_BUCKET: 'your-space-name',
                        DIGITAL_OCEAN_REGION: 'sfo3',
                        // Note: actual credentials should NEVER be sent to client
                        // This is just using placeholder values for demo
                        
                        IPFS_ENABLED: false,
                        IPFS_GATEWAY_URL: 'https://ipfs.io/ipfs/',
                        PINATA_API_KEY: 'your_pinata_api_key', // Only public key if needed client-side
                        
                        GOOGLE_CLOUD_ENABLED: false,
                        GOOGLE_CLOUD_BUCKET_NAME: 'your-bucket-name',
                        GOOGLE_CLOUD_PROJECT_ID: 'your-project-id',
                        
                        LOCAL_ENABLED: true,
                        LOCAL_MEDIA_PATH: './content/',
                        
                        MAX_CONCURRENT_LOADS: 5,
                        PRELOAD_DISTANCE: 2,
                        SMOOTH_SCROLL_DURATION: 500,
                        AUTO_PLAY_VIDEOS: true,
                        AUTO_PLAY_AUDIO: true,
                        
                        // Seasonal layout configuration
                        CURRENT_SEASON: 'season-1', // Change this to switch layouts: 'season-1', 'season-2', 'season-3', 'season-4', 'season-5', 'season-6'
                        ENABLE_ARCHIVE_MODE: false,
                    };
                }
            } catch (error) {
                console.error('Error loading environment:', error);
                // Use default fallback values
                env = {
                    DIGITAL_OCEAN_ENABLED: false,
                    DIGITAL_OCEAN_ENDPOINT: 'https://your-space-name.sfo3.digitaloceanspaces.com',
                    DIGITAL_OCEAN_BUCKET: 'your-space-name',
                    DIGITAL_OCEAN_REGION: 'sfo3',
                    
                    IPFS_ENABLED: false,
                    IPFS_GATEWAY_URL: 'https://ipfs.io/ipfs/',
                    PINATA_API_KEY: 'your_pinata_api_key',
                    
                    GOOGLE_CLOUD_ENABLED: false,
                    GOOGLE_CLOUD_BUCKET_NAME: 'your-bucket-name',
                    GOOGLE_CLOUD_PROJECT_ID: 'your-project-id',
                    
                    LOCAL_ENABLED: true,
                    LOCAL_MEDIA_PATH: './content/',
                    
                    MAX_CONCURRENT_LOADS: 5,
                    PRELOAD_DISTANCE: 2,
                    SMOOTH_SCROLL_DURATION: 500,
                    AUTO_PLAY_VIDEOS: true,
                    AUTO_PLAY_AUDIO: true,
                    
                    // Seasonal layout configuration
                    CURRENT_SEASON: 'season-1', // Change this to switch layouts: 'season-1', 'season-2', 'season-3', 'season-4', 'season-5', 'season-6'
                    ENABLE_ARCHIVE_MODE: false,
                };
            }
        }
        
        // Gallery state
        let mediaItems = [];
        let currentIndex = 0;
        let galleryElement = null;
        let isAnimating = false;
        
        // Supported file extensions
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg', '.tiff', '.ico', '.avif', '.heic', '.jfif'];
        const videoExtensions = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.mkv', '.m4v', '.3gp', '.wmv', '.flv', '.m3u8'];
        const audioExtensions = ['.mp3', '.flac', '.wav', '.ogg', '.m4a', '.aac', '.wma', '.opus', '.aiff', '.alac'];
        const textExtensions = ['.txt', '.md', '.markdown', '.rtf', '.doc', '.docx'];
        
        // Zine style variations
        const zineStyles = ['zine-style-1', 'zine-style-2', 'zine-style-3', 'zine-style-4', 'zine-style-5', 'zine-style-6'];
        
        // Initialize the gallery
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize environment from secure source
            await initializeEnvironment();
            
            galleryElement = document.getElementById('gallery');
            
            // Load media from configured sources
            await loadMedia();
            
            // Initialize controls
            initControls();
            
            // Initialize archive system
            initializeArchiveSystem();
            
            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';
        });
        
        // Load media from all configured sources
        async function loadMedia() {
            // Start with local media if enabled
            let allMedia = [];
            if (env.LOCAL_ENABLED) {
                const localMedia = await loadLocalMedia();
                allMedia = [...allMedia, ...localMedia];
            }
            
            // Load from cloud providers
            if (env.DIGITAL_OCEAN_ENABLED) {
                const doMedia = await loadFromDigitalOcean();
                allMedia = [...allMedia, ...doMedia];
            }
            
            if (env.IPFS_ENABLED) {
                const ipfsMedia = await loadFromIPFS();
                allMedia = [...allMedia, ...ipfsMedia];
            }
            
            if (env.GOOGLE_CLOUD_ENABLED) {
                const gcMedia = await loadFromGoogleCloud();
                allMedia = [...allMedia, ...gcMedia];
            }
            
            // For demo purposes, if no media is loaded, create some placeholder items
            if (allMedia.length === 0) {
                // Check for files in the content directory using the old method
                allMedia = await loadFromGitHubRepo();
            }
            
            // Combine all media items
            mediaItems = allMedia;
            
            // Render the gallery
            renderGallery();
        }
        
        // Load media from GitHub repo (fallback for demo)
        async function loadFromGitHubRepo() {
            try {
                const username = 'quazf';
                const repo = 'gridWoooorld';
                const path = 'content';
                const apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${path}`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                const media = [];
                for (let item of data) {
                    if (item.type === 'file') {
                        const fileName = item.name.toLowerCase();
                        const fileUrl = item.download_url;
                        
                        // Determine media type based on file extension
                        if (fileName.match(/\.(jpe?g|png|gif|webp|bmp|svg|tiff?|ico|avif|heic|jfif)$/i)) {
                            media.push({
                                filename: item.name,
                                url: fileUrl,
                                type: 'image',
                                source: 'github'
                            });
                        } else if (fileName.match(/\.(mp4|webm|ogg|mov|avi|mkv|m4v|3gp|wmv|flv|m3u8)$/i)) {
                            media.push({
                                filename: item.name,
                                url: fileUrl,
                                type: 'video',
                                source: 'github'
                            });
                        } else if (fileName.match(/\.(mp3|flac|wav|ogg|m4a|aac|wma|opus|aiff|alac)$/i)) {
                            media.push({
                                filename: item.name,
                                url: fileUrl,
                                type: 'audio',
                                source: 'github'
                            });
                        } else if (fileName.match(/\.(txt|md|markdown|rtf|doc|docx)$/i)) {
                            media.push({
                                filename: item.name,
                                url: fileUrl,
                                type: 'text',
                                source: 'github'
                            });
                        }
                    }
                }
                
                return media;
            } catch (error) {
                console.error('Error loading media from GitHub:', error);
                return [];
            }
        }
        
        // Load media from local content folder
        async function loadLocalMedia() {
            try {
                // In a real implementation, this would be handled server-side
                // For now, we'll fetch a manifest file that lists the content
                // First check if content/manifest.json exists
                const response = await fetch(`${env.LOCAL_MEDIA_PATH}manifest.json`).catch(() => null);
                
                if (response && response.ok) {
                    const manifest = await response.json();
                    return manifest.map(item => ({
                        ...item,
                        url: `${env.LOCAL_MEDIA_PATH}${item.filename}`,
                        source: 'local'
                    }));
                } else {
                    // Fallback: scan the content directory for files
                    // This requires a server endpoint to list directory contents
                    // Since we can't do that client-side due to security restrictions,
                    // we'll create a mock implementation that looks for common file types
                    console.log("Manifest file not found, using fallback method");
                    return []; // In real implementation, this would call server endpoint
                }
            } catch (error) {
                console.error('Error loading local media:', error);
                return [];
            }
        }
        
        // Load media from DigitalOcean Spaces
        async function loadFromDigitalOcean() {
            // In a real implementation, you'd use the DO Spaces API
            // This requires server-side code to generate signed URLs for security
            // Client-side access keys are insecure in production
            // This is a placeholder for the server-side API call
            try {
                // In production, you would call your backend API to get signed URLs
                // that can securely access your DigitalOcean Spaces content
                const response = await fetch('/api/digitalocean-files', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${getAuthToken()}`
                    },
                    body: JSON.stringify({
                        endpoint: env.DIGITAL_OCEAN_ENDPOINT,
                        bucket: env.DIGITAL_OCEAN_BUCKET,
                        region: env.DIGITAL_OCEAN_REGION
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.files.map(item => ({
                        filename: item.name,
                        url: item.url, // Pre-signed URL from backend
                        type: item.type,
                        source: 'digitalocean'
                    }));
                } else {
                    console.error('Failed to load from DigitalOcean:', response.status);
                    return [];
                }
            } catch (error) {
                console.error('Error loading from DigitalOcean:', error);
                return [];
            }
        }
        
        // Helper function to get authentication token
        function getAuthToken() {
            // In a real implementation, you'd retrieve this from secure storage
            // or implement proper authentication
            return localStorage.getItem('galleryAuthToken') || sessionStorage.getItem('galleryAuthToken');
        }
        
        // Load media from IPFS
        async function loadFromIPFS() {
            try {
                // In a real implementation, you'd either:
                // 1. Query a manifest file stored on IPFS that lists your content
                // 2. Use Pinata API to get a list of your pinned files
                // This requires a server-side endpoint for security
                
                const response = await fetch('/api/ipfs-files', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${getAuthToken()}`
                    },
                    body: JSON.stringify({
                        gatewayUrl: env.IPFS_GATEWAY_URL,
                        pinataApiKey: env.PINATA_API_KEY,
                        // Only the API key is sent, secret should be stored server-side
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.files.map(item => ({
                        filename: item.name,
                        url: `${env.IPFS_GATEWAY_URL}${item.cid}`, // IPFS content identifier
                        type: item.type,
                        source: 'ipfs'
                    }));
                } else {
                    console.error('Failed to load from IPFS:', response.status);
                    return [];
                }
            } catch (error) {
                console.error('Error loading from IPFS:', error);
                return [];
            }
        }
        
        // Load media from Google Cloud Storage
        async function loadFromGoogleCloud() {
            try {
                // In a real implementation, you'd use a server-side endpoint
                // to generate signed URLs for secure access to GCS content
                const response = await fetch('/api/google-cloud-files', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${getAuthToken()}`
                    },
                    body: JSON.stringify({
                        bucketName: env.GOOGLE_CLOUD_BUCKET_NAME,
                        projectId: env.GOOGLE_CLOUD_PROJECT_ID
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.files.map(item => ({
                        filename: item.name,
                        url: item.signedUrl, // Secure signed URL from backend
                        type: item.type,
                        source: 'googlecloud'
                    }));
                } else {
                    console.error('Failed to load from Google Cloud:', response.status);
                    return [];
                }
            } catch (error) {
                console.error('Error loading from Google Cloud:', error);
                return [];
            }
        }
        
        // Render the gallery with media items
        function renderGallery() {
            galleryElement.innerHTML = '';
            
            mediaItems.forEach((item, index) => {
                const mediaItem = createMediaElement(item, index);
                galleryElement.appendChild(mediaItem);
            });
            
            goToSlide(currentIndex);
            
            // Update visible slides after initial render
            setTimeout(() => updateVisibleSlides(currentIndex), 100);
        }
        
        // Advanced text content categorization system with improved accuracy
        function categorizeTextContent(content, filename) {
            const lines = content.split('\n').filter(line => line.trim() !== '');
            const wordCount = content.trim().split(/\s+/).length;
            const lineCount = lines.length;
            const charCount = content.length;
            const paragraphCount = content.split(/\n\s*\n/).filter(p => p.trim() !== '').length;
            
            // Check for poem characteristics (structured lines, stanzas)
            const hasManyShortLines = lines.filter(line => line.trim().length < 40 && line.trim().length > 0).length > lineCount * 0.6;
            const hasEmptyLines = content.includes('\n\n'); // indicates stanzas
            const hasRhymePattern = (content.match(/\b(\w+)(?:\s+\w+)*\s+\1\b/gi) !== null) || 
                                  (content.toLowerCase().includes('rhyme') || content.toLowerCase().includes('verse'));
            
            // Check for aphorism/rambling characteristics (short entries, quotes)
            const hasQuotePattern = (content.match(/[""''""]/g) || []).length > 2;
            const hasManyShortParagraphs = lines.filter(line => line.trim().length < 80 && line.trim().length > 5).length > 2;
            const hasListPattern = (content.match(/^-|\*|\d+\./gm) || []).length > 2;
            const hasTwitterPattern = wordCount < 280 && (content.includes('@') || content.includes('#'));
            
            // Check for article characteristics (longer paragraphs, structured)
            const avgLineLength = content.length / Math.max(lineCount, 1);
            const avgParagraphLength = wordCount / Math.max(paragraphCount, 1);
            const hasArticleStructure = content.toLowerCase().includes('introduction') || 
                                      content.toLowerCase().includes('conclusion') ||
                                      content.toLowerCase().includes('section') ||
                                      content.toLowerCase().includes('abstract') ||
                                      content.toLowerCase().includes('summary') ||
                                      content.match(/^#+\s.+/gm) !== null; // markdown headers
            
            // Check for magazine-like structure (subheadings, bylines)
            const hasMagStructure = content.toLowerCase().includes('by ') || 
                                  content.toLowerCase().includes('published') ||
                                  content.toLowerCase().includes('issue') ||
                                  content.toLowerCase().includes('volume') ||
                                  content.includes('---') || content.includes('...') || 
                                  (content.match(/^#+\s.*$/gm) !== null && wordCount > 100);
            
            // Check for caption characteristics (very short, descriptive)
            const isVeryShort = wordCount < 25;
            const hasCaptionMarkers = content.toLowerCase().match(/\b(image|photo|figure|caption|view|scene|detail|illustration|screenshot|depicts|shows|portrays)\b/g) !== null;
            
            // Check for formal academic characteristics
            const hasAcademicMarkers = content.toLowerCase().includes('abstract') ||
                                     content.toLowerCase().includes('methodology') ||
                                     content.toLowerCase().includes('references') ||
                                     content.toLowerCase().includes('bibliography') ||
                                     content.toLowerCase().includes('footnote') ||
                                     content.toLowerCase().includes('acknowledgement') ||
                                     content.match(/\[\d+\]/g) !== null || // Citation patterns
                                     content.toLowerCase().includes('theorem') ||
                                     content.toLowerCase().includes('lemma') ||
                                     content.toLowerCase().includes('corollary');
            
            // Check for magazine/newspaper article characteristics
            const hasNewsMarkers = content.toLowerCase().includes('said') ||
                                 content.toLowerCase().includes('report') ||
                                 content.toLowerCase().includes('according to') ||
                                 content.toLowerCase().includes('recently') ||
                                 content.toLowerCase().includes('noted that') ||
                                 content.toLowerCase().includes('yesterday') ||
                                 content.toLowerCase().includes('today') ||
                                 content.toLowerCase().includes('this week');
            
            // Check for diary/journal characteristics
            const hasDateMarkers = content.match(/\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/) !== null ||
                                 content.toLowerCase().includes('today') ||
                                 content.toLowerCase().includes('yesterday') ||
                                 content.toLowerCase().includes('dear diary') ||
                                 content.toLowerCase().includes('journal entry');
            
            // Check for social media patterns
            const hasSocialPattern = hasTwitterPattern || 
                                   content.includes('RT') || 
                                   content.includes('hashtag') ||
                                   content.toLowerCase().includes('update') ||
                                   (wordCount < 100 && content.includes('?') && content.includes('!'));
            
            // Enhanced classification logic with better granularity
            if (isVeryShort && hasCaptionMarkers) {
                return 'caption';
            } else if (wordCount < 30 && !hasArticleStructure && !hasMagStructure && !hasListPattern) {
                return 'maximalist'; // Very short but impactful phrases
            } else if (hasDateMarkers && wordCount < 500) {
                return 'journal'; // Personal journal/diary entry
            } else if (hasSocialPattern && wordCount < 280) {
                return 'social'; // Social media style content
            } else if (hasManyShortLines && hasEmptyLines && !hasRhymePattern) {
                return 'poem';
            } else if (hasRhymePattern && hasManyShortLines) {
                return 'verse'; // For rhyming poems
            } else if ((hasManyShortParagraphs || hasQuotePattern) && wordCount < 300 && !hasArticleStructure) {
                return 'aphorisms'; // Aphorisms, ramblings, quotes
            } else if (hasMagStructure && wordCount > 200) {
                return 'magazine'; // Magazine-style article
            } else if (hasArticleStructure || hasAcademicMarkers || (wordCount > 500 && avgParagraphLength > 50)) {
                return 'article'; // Standard article
            } else if (hasNewsMarkers && wordCount > 100) {
                return 'news'; // News-style article
            } else if (hasListPattern && wordCount < 500) {
                return 'listicle'; // List-based content
            } else if (wordCount > 1000) {
                return 'longform'; // Long-form content
            } else {
                return 'standard'; // Default category for regular content
            }
        }
        
        // Generate content layout based on category
        function generateTextLayout(content, category, extension, filename) {
            switch(category) {
                case 'maximalist':
                    // Full-page impactful phrase
                    if (extension === '.md' || extension === '.markdown') {
                        return `
                            <div style="display: flex; flex-direction: column; justify-content: center; height: 100%; width: 100%;">
                                <h1>${marked.parseInline(content.trim())}</h1>
                            </div>
                        `;
                    } else {
                        return `
                            <div style="display: flex; flex-direction: column; justify-content: center; height: 100%; width: 100%;">
                                <h1>${escapeHtml(content.trim())}</h1>
                            </div>
                        `;
                    }
                
                case 'aphorisms':
                    // Rambling entries with alternating alignment and positioning
                    const lines = content.split('\n').filter(line => line.trim() !== '');
                    let entriesHtml = '';
                    
                    lines.forEach((line, index) => {
                        if (line.trim()) {
                            // Alternate between left and right alignment
                            const alignmentClass = index % 2 === 0 ? 'aphorism-left' : 'aphorism-right';
                            entriesHtml += `
                                <div class="aphorism-entry ${alignmentClass}">
                                    ${extension === '.md' || extension === '.markdown' ? marked.parseInline(line.trim()) : escapeHtml(line.trim())}
                                </div>
                            `;
                        }
                    });
                    
                    return entriesHtml;
                
                case 'article':
                    // Structured article format with formal typography
                    if (extension === '.md' || extension === '.markdown') {
                        return marked.parse(content, {
                            gfm: true,
                            breaks: true,
                            smartypants: true
                        });
                    } else {
                        // For plain text, add basic formatting
                        const paragraphs = content.split(/\n\s*\n/);
                        let formattedContent = '';
                        
                        paragraphs.forEach(paragraph => {
                            if (paragraph.trim()) {
                                // Check if this is a title (short line, few words)
                                if (paragraph.trim().split(/\s+/).length < 10 && paragraph.length < 100) {
                                    formattedContent += `<h2>${escapeHtml(paragraph.trim())}</h2>`;
                                } else {
                                    formattedContent += `<p>${escapeHtml(paragraph).replace(/\n/g, '<br>')}</p>`;
                                }
                            }
                        });
                        
                        return formattedContent;
                    }
                
                case 'magazine':
                    // Magazine-style layout with formal typography
                    return generateMagazineLayout(content, extension);
                
                case 'poem':
                    // Poem with line breaks preserved
                    const lines = content.split('\n');
                    let poemHtml = '<div class="poem-lines">';
                    lines.forEach(line => {
                        if (line.trim()) {
                            poemHtml += `<div>${extension === '.md' || extension === '.markdown' ? marked.parseInline(line.trim()) : escapeHtml(line.trim())}</div>`;
                        } else {
                            poemHtml += '</div><div class="poem-lines">'; // New stanza
                        }
                    });
                    poemHtml += '</div>';
                    return poemHtml;
                
                case 'verse':
                    // Rhyming verse with special formatting
                    const verseLines = content.split('\n');
                    let verseHtml = '<div class="poem-lines" style="font-style: italic;">';
                    verseLines.forEach(line => {
                        if (line.trim()) {
                            verseHtml += `<div>${extension === '.md' || extension === '.markdown' ? marked.parseInline(line.trim()) : escapeHtml(line.trim())}</div>`;
                        } else {
                            verseHtml += '</div><div class="poem-lines" style="font-style: italic;">'; // New stanza
                        }
                    });
                    verseHtml += '</div>';
                    return verseHtml;
                
                case 'news':
                    // News article format
                    return generateNewsLayout(content, extension);
                
                case 'listicle':
                    // List-based content
                    return generateListicleLayout(content, extension);
                
                case 'caption':
                    // Simple caption format
                    if (extension === '.md' || extension === '.markdown') {
                        return `<p>${marked.parseInline(content.trim())}</p>`;
                    } else {
                        return `<p>${escapeHtml(content.trim())}</p>`;
                    }
                
                default:
                    // Fallback to original behavior
                    if (extension === '.md' || extension === '.markdown') {
                        return marked.parse(content, {
                            gfm: true,
                            breaks: true,
                            smartypants: true
                        });
                    } else {
                        return `<p>${escapeHtml(content).replace(/\n/g, '<br>')}</p>`;
                    }
            }
        }
        
        // Create a media element based on file type
        function createMediaElement(item, index) {
            const mediaItem = document.createElement('div');
            mediaItem.className = 'media-item';
            mediaItem.dataset.index = index;
            
            // Initially hide items that are not near the current index
            if (Math.abs(index - currentIndex) > env.PRELOAD_DISTANCE) {
                mediaItem.style.display = 'none';
            }
            
            // Set seasonal class on media item if it's text content
            if (textExtensions.includes(getFileExtension(item.filename).toLowerCase())) {
                mediaItem.dataset.season = env.CURRENT_SEASON;
            }
            
            const mediaContent = document.createElement('div');
            mediaContent.className = 'media-content';
            
            const extension = getFileExtension(item.filename).toLowerCase();
            
            if (imageExtensions.includes(extension)) {
                // Image content
                const img = document.createElement('img');
                img.src = item.url;
                img.alt = item.filename;
                img.loading = 'lazy';
                // Add animation for image loading
                img.style.opacity = '0';
                img.onload = () => {
                    // Smooth fade-in when image loads
                    img.style.transition = 'opacity 0.5s ease-in-out';
                    img.style.opacity = '1';
                };
                mediaContent.appendChild(img);
            } else if (videoExtensions.includes(extension)) {
                // Video content
                const video = document.createElement('video');
                video.src = item.url;
                video.controls = false;
                video.muted = true;
                video.loop = true;
                video.autoplay = env.AUTO_PLAY_VIDEOS;
                video.playsInline = true; // For iOS Safari
                // Only preload metadata for videos not near current index
                video.preload = Math.abs(index - currentIndex) <= env.PRELOAD_DISTANCE ? 'auto' : 'metadata';
                
                // Add play/pause on click
                video.addEventListener('click', () => {
                    if (video.paused) {
                        video.play();
                    } else {
                        video.pause();
                    }
                });
                
                mediaContent.appendChild(video);
            } else if (audioExtensions.includes(extension)) {
                // Audio content with visualization
                const audioContainer = document.createElement('div');
                audioContainer.className = 'audio-content';
                
                const title = document.createElement('h3');
                title.textContent = item.filename;
                audioContainer.appendChild(title);
                
                const vizContainer = document.createElement('div');
                vizContainer.className = 'audio-visualization';
                vizContainer.id = `audio-viz-${index}`;
                audioContainer.appendChild(vizContainer);
                
                const audioInfo = document.createElement('div');
                audioInfo.className = 'audio-info';
                
                const audio = document.createElement('audio');
                audio.src = item.url;
                audio.controls = false; // Hide controls since we're auto-playing
                audio.preload = 'auto'; // Preload audio for smooth playback
                audio.autoplay = env.AUTO_PLAY_AUDIO; // Enable audio autoplay as requested
                audioInfo.appendChild(audio);
                
                audioContainer.appendChild(audioInfo);
                mediaContent.appendChild(audioContainer);
                
                // Initialize waveform visualization only when near current index
                if (Math.abs(index - currentIndex) <= env.PRELOAD_DISTANCE) {
                    setTimeout(() => {
                        initAudioVisualization(`audio-viz-${index}`, item.url, index);
                    }, 100);
                }
            } else if (textExtensions.includes(extension)) {
                // Text/Markdown content with intelligent categorization
                const textContainer = document.createElement('div');
                
                // Apply a random zine style to each text item
                const randomStyle = zineStyles[Math.floor(Math.random() * zineStyles.length)];
                
                // Start with basic classes
                textContainer.className = `text-content ${env.CURRENT_SEASON} ${randomStyle}`;
                
                // Add loading indicator
                textContainer.innerHTML = '<p>Loading content...</p>';
                
                // Fetch and categorize content
                fetchTextContent(item.url).then(content => {
                    // Categorize the text content
                    const category = categorizeTextContent(content, item.filename);
                    
                    // Add category class to the text container
                    textContainer.classList.add(`category-${category}`);
                    
                    // Generate layout based on category
                    textContainer.innerHTML = generateTextLayout(content, category, extension);
                    
                    // Handle poem titles specially
                    if (category === 'poem' && content.trim().split('\n')[0].length < 100 && !content.trim().split('\n')[0].includes(' ')) {
                        const firstLine = content.trim().split('\n')[0];
                        const restOfPoem = content.trim().split('\n').slice(1).join('\n');
                        textContainer.innerHTML = `
                            <div class="poem-title">${escapeHtml(firstLine)}</div>
                            <div class="poem-lines">
                                ${restOfPoem.split('\n').filter(line => line.trim() !== '').map(line => 
                                    `<div>${escapeHtml(line)}</div>`
                                ).join('')}
                            </div>
                        `;
                    }
                    
                    // Update archive counts if enabled
                    if (window.galleryArchive && window.galleryArchive.textCategories[category]) {
                        window.galleryArchive.textCategories[category].count += 1;
                    }
                    
                    // Store category in media item for archival purposes
                    if (mediaItems[index]) {
                        mediaItems[index].textCategory = category;
                        
                        // Also attempt to find associated images for all text content types
                        findAssociatedImages(item.filename).then(images => {
                            if (images.length > 0) {
                                // Add the first associated image to the content (for articles, poems, etc.)
                                addImageToTextContent(index, images[0].url, images[0].caption);
                            }
                        });
                    }
                }).catch(err => {
                    textContainer.innerHTML = `<p>Error loading content: ${err.message}</p>`;
                });
                
                mediaContent.appendChild(textContainer);
            }
            
            mediaItem.appendChild(mediaContent);
            return mediaItem;
        }
        
        // Generate magazine-style layout
        function generateMagazineLayout(content, extension) {
            if (extension === '.md' || extension === '.markdown') {
                // Parse markdown and add magazine-specific classes
                let html = marked.parse(content, {
                    gfm: true,
                    breaks: true,
                    smartypants: true
                });
                
                // Add magazine styling classes
                html = html.replace(/<h1>(.*?)<\/h1>/, '<h1>$1</h1>');
                html = html.replace(/<h2>(.*?)<\/h2>/g, '<div class="section-title">$1</div>');
                return html;
            } else {
                // Parse plain text for magazine structure
                const paragraphs = content.split(/\n\s*\n/);
                let formattedContent = '';
                
                // Find title (first short paragraph)
                const title = paragraphs[0] && paragraphs[0].split(/\s+/).length < 10 && paragraphs[0].length < 100 
                    ? paragraphs.shift() : '';
                const author = paragraphs[1] && paragraphs[1].toLowerCase().includes('by ') 
                    ? paragraphs.splice(1, 1)[0] : '';
                
                if (title) {
                    formattedContent += `<h1>${escapeHtml(title.trim())}</h1>`;
                }
                if (author) {
                    formattedContent += `<div class="author">${escapeHtml(author.trim())}</div>`;
                }
                
                // Process remaining paragraphs
                paragraphs.forEach(paragraph => {
                    if (paragraph.trim()) {
                        if (paragraph.trim().split(/\s+/).length < 10 && paragraph.length < 100) {
                            // Short lines might be section headers
                            formattedContent += `<div class="section-title">${escapeHtml(paragraph.trim())}</div>`;
                        } else {
                            formattedContent += `<p>${escapeHtml(paragraph).replace(/\n/g, '<br>')}</p>`;
                        }
                    }
                });
                
                return formattedContent;
            }
        }
        
        // Generate news-style layout
        function generateNewsLayout(content, extension) {
            if (extension === '.md' || extension === '.markdown') {
                return marked.parse(content, {
                    gfm: true,
                    breaks: true,
                    smartypants: true
                });
            } else {
                const paragraphs = content.split(/\n\s*\n/);
                let formattedContent = '';
                
                // Identify news elements
                let title = '';
                let byline = '';
                
                for (let i = 0; i < Math.min(3, paragraphs.length); i++) {
                    const para = paragraphs[i];
                    if (para.split(/\s+/).length < 10 && para.length < 100 && !title) {
                        title = para;
                        paragraphs[i] = '';
                    } else if (para.toLowerCase().includes('by ') && !byline) {
                        byline = para;
                        paragraphs[i] = '';
                    }
                }
                
                if (title) {
                    formattedContent += `<h1 style="text-align: left; color: #fff;">${escapeHtml(title.trim())}</h1>`;
                }
                if (byline) {
                    formattedContent += `<div class="byline" style="margin-bottom: 1.5rem;">${escapeHtml(byline.trim())}</div>`;
                }
                
                paragraphs.forEach(paragraph => {
                    if (paragraph.trim()) {
                        formattedContent += `<p>${escapeHtml(paragraph).replace(/\n/g, '<br>')}</p>`;
                    }
                });
                
                return formattedContent;
            }
        }
        
        // Generate listicle layout
        function generateListicleLayout(content, extension) {
            if (extension === '.md' || extension === '.markdown') {
                return marked.parse(content, {
                    gfm: true,
                    breaks: true,
                    smartypants: true
                });
            } else {
                const lines = content.split('\n');
                let formattedContent = '<ol>';
                
                lines.forEach(line => {
                    if (line.trim() && (line.startsWith('- ') || line.match(/^\d+\./) || line.match(/^[a-zA-Z]\./))) {
                        formattedContent += `<li>${escapeHtml(line.replace(/^[^a-zA-Z0-9]*\s*/, ''))}</li>`;
                    } else if (line.trim()) {
                        formattedContent += `<p>${escapeHtml(line.trim())}</p>`;
                    }
                });
                
                formattedContent += '</ol>';
                return formattedContent;
            }
        }
        
        // Function to find associated images for text content
        async function findAssociatedImages(textFilename) {
            const textBasename = textFilename.replace(/\.[^/.]+$/, ""); // Remove extension
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            
            try {
                // In a real implementation, this would query a media API or directory listing
                // For now, we'll look for common naming patterns in the same directory
                // This is a simplified example - in a real app, you'd have a database or API
                const potentialImages = [];
                
                // Look for common patterns like textfilename.jpg, textfilename-image.jpg, etc.
                for (const ext of imageExtensions) {
                    potentialImages.push(`${textBasename}${ext}`);
                    potentialImages.push(`${textBasename}_image${ext}`);
                    potentialImages.push(`${textBasename}-img${ext}`);
                    potentialImages.push(`${textBasename}-background${ext}`);
                }
                
                // In a real implementation, you would check if these files exist
                // For demo purposes, return example image paths
                // In a real app, you would use a backend service to check file existence
                return potentialImages.map((imgName, idx) => ({
                    url: `./content/${imgName}`, // This would be dynamically determined
                    caption: `Associated image ${idx + 1} for ${textBasename}`,
                    type: 'inline' // or 'background'
                })).slice(0, 2); // Return first 2 as example
                
            } catch (error) {
                console.error('Error finding associated images:', error);
                return [];
            }
        }
        
        // Function to add image to text content
        function addImageToTextContent(index, imageUrl, caption = '', imageType = 'inline') {
            if (mediaItems[index] && textExtensions.includes(getFileExtension(mediaItems[index].filename))) {
                const textContainer = document.querySelector(`.media-item[data-index="${index}"] .text-content`);
                if (textContainer) {
                    if (imageType === 'background') {
                        // Apply as background image
                        textContainer.style.backgroundImage = `url('${imageUrl}')`;
                        textContainer.style.backgroundSize = 'cover';
                        textContainer.style.backgroundPosition = 'center';
                        textContainer.style.backgroundBlendMode = 'multiply'; // Blend text with background
                    } else {
                        // Create image element for inline display
                        const imgElement = document.createElement('img');
                        imgElement.src = imageUrl;
                        imgElement.className = 'article-image';
                        imgElement.alt = caption || 'Associated image';
                        
                        // Create caption element if provided
                        if (caption) {
                            const captionElement = document.createElement('div');
                            captionElement.className = 'caption';
                            captionElement.textContent = caption;
                            
                            // Insert image and caption into the text container
                            textContainer.appendChild(imgElement);
                            textContainer.appendChild(captionElement);
                        } else {
                            textContainer.appendChild(imgElement);
                        }
                    }
                }
            }
        }
        
        // Initialize audio visualization using wavesurfer.js with enhanced effects
        function initAudioVisualization(containerId, audioUrl, index) {
            // Check if the element still exists (in case of rapid navigation)
            if (!document.getElementById(containerId)) return;
            
            // Create a more sophisticated visualization
            const wavesurfer = WaveSurfer.create({
                container: `#${containerId}`,
                waveColor: '#6c63ff',
                progressColor: {
                    // Gradient progress color
                    0: '#ff7eb9',
                    1: '#ff758c'
                },
                cursorColor: '#fff',
                barWidth: 4,
                barRadius: 3,
                barGap: 2,
                height: 200,
                responsive: true,
                normalize: true,
                partialRender: true
            });
            
            wavesurfer.load(audioUrl);
            
            // Add play/pause toggle on click
            document.getElementById(containerId).addEventListener('click', () => {
                if (wavesurfer.isPlaying()) {
                    wavesurfer.pause();
                } else {
                    wavesurfer.play();
                }
            });
            
            // Auto-play when visualization is ready if enabled
            wavesurfer.on('ready', () => {
                if (env.AUTO_PLAY_AUDIO) {
                    wavesurfer.play().catch(e => console.log("Auto-play prevented by browser policy:", e));
                }
            });
            
            // Add visual feedback when playing
            wavesurfer.on('play', () => {
                document.getElementById(containerId).style.boxShadow = '0 0 20px rgba(108, 99, 255, 0.7)';
                document.getElementById(containerId).style.transform = 'scale(1.02)';
                document.getElementById(containerId).style.transition = 'transform 0.3s ease, box-shadow 0.3s ease';
            });
            
            wavesurfer.on('pause', () => {
                document.getElementById(containerId).style.boxShadow = 'none';
                document.getElementById(containerId).style.transform = 'scale(1)';
            });
            
            // Add visual effect on finish
            wavesurfer.on('finish', () => {
                document.getElementById(containerId).style.boxShadow = '0 0 30px rgba(74, 69, 196, 0.9)';
                setTimeout(() => {
                    if (!wavesurfer.isPlaying()) {
                        document.getElementById(containerId).style.boxShadow = 'none';
                    }
                }, 1000);
            });
            
            // Store wavesurfer instance for potential cleanup
            mediaItems[index].wavesurfer = wavesurfer;
        }
        
        // Fetch text content from URL
        async function fetchTextContent(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.text();
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        
        // Get file extension
        function getFileExtension(filename) {
            return filename.slice(filename.lastIndexOf('.')).toLowerCase();
        }
        
        // Initialize controls
        function initControls() {
            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') showPrevious();
                if (e.key === 'ArrowRight') showNext();
                
                // Hidden developer controls for seasonal layout cycling (Ctrl+Shift+1-6)
                if (e.ctrlKey && e.shiftKey) {
                    if (e.key === '1') switchSeason('season-1');
                    if (e.key === '2') switchSeason('season-2');
                    if (e.key === '3') switchSeason('season-3');
                    if (e.key === '4') switchSeason('season-4');
                    if (e.key === '5') switchSeason('season-5');
                    if (e.key === '6') switchSeason('season-6');
                }
            });
            
            // Touch/swipe support
            let touchStartX = 0;
            let touchEndX = 0;
            
            galleryElement.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
            }, false);
            
            galleryElement.addEventListener('touchend', e => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            }, false);
            
            // Mouse drag support
            let isDragging = false;
            let dragStartX = 0;
            
            galleryElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStartX = e.clientX;
                galleryElement.style.cursor = 'grabbing';
            });
            
            galleryElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                // Could add visual feedback here
            });
            
            galleryElement.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    const dragEndX = e.clientX;
                    const diffX = dragStartX - dragEndX;
                    
                    if (Math.abs(diffX) > 50) { // Threshold for swipe
                        if (diffX > 0) {
                            showNext(); // Swipe left - next
                        } else {
                            showPrevious(); // Swipe right - previous
                        }
                    }
                    
                    isDragging = false;
                    galleryElement.style.cursor = 'default';
                }
            });
            
            galleryElement.addEventListener('mouseleave', () => {
                isDragging = false;
                galleryElement.style.cursor = 'default';
            });
        }
        
        // Handle swipe gesture
        function handleSwipe() {
            const minSwipeDistance = 50;
            
            if (touchStartX - touchEndX > minSwipeDistance) {
                // Swipe left - next
                showNext();
            } else if (touchEndX - touchStartX > minSwipeDistance) {
                // Swipe right - previous
                showPrevious();
            }
        }
        
        // Show next media item
        function showNext() {
            if (isAnimating || mediaItems.length <= 1) return;
            
            currentIndex = (currentIndex + 1) % mediaItems.length;
            goToSlide(currentIndex);
        }
        
        // Show previous media item
        function showPrevious() {
            if (isAnimating || mediaItems.length <= 1) return;
            
            currentIndex = (currentIndex - 1 + mediaItems.length) % mediaItems.length;
            goToSlide(currentIndex);
        }
        
        // Go to specific slide with enhanced animation using improved CSS transitions
        function goToSlide(index) {
            if (isAnimating) return;
            
            isAnimating = true;
            
            // Pause any playing audio in the current slide
            pauseCurrentAudio();
            
            // Fade out current slide before transition
            const currentSlide = galleryElement.children[currentIndex];
            if (currentSlide) {
                currentSlide.style.transition = 'opacity 0.25s ease-in-out';
                currentSlide.style.opacity = '0';
            }
            
            // Wait for fade out before sliding
            setTimeout(() => {
                // Calculate the translateX value to move to the correct slide
                const translateX = -index * 100;
                
                // Apply the transformation with improved smooth transition and custom easing
                // Using a more complex cubic-bezier for smoother acceleration/deceleration
                galleryElement.style.transition = `transform ${env.SMOOTH_SCROLL_DURATION}ms cubic-bezier(0.23, 1, 0.32, 1)`;
                galleryElement.style.transform = `translateX(${translateX}%)`;
                
                // After the slide transition completes
                setTimeout(() => {
                    // Fade in the new slide
                    const newSlide = galleryElement.children[index];
                    if (newSlide) {
                        newSlide.style.transition = 'opacity 0.25s ease-in-out 0.05s';
                        newSlide.style.opacity = '1';
                    }
                    
                    // Show nearby slides and hide distant ones for performance
                    updateVisibleSlides(index);
                    
                    // Preload content near the new position
                    preloadNearbyContent(index);
                    
                    playCurrentAudio();
                    isAnimating = false;
                }, env.SMOOTH_SCROLL_DURATION - 25); // Slightly before to feel smoother
            }, 150); // Reduced from 250ms for more responsive feel
        }
        
        // Pause audio in current slide
        function pauseCurrentAudio() {
            const currentMedia = mediaItems[currentIndex];
            if (currentMedia && currentMedia.wavesurfer) {
                currentMedia.wavesurfer.pause();
            }
        }
        
        // Play audio in current slide
        function playCurrentAudio() {
            const currentMedia = mediaItems[currentIndex];
            if (currentMedia && currentMedia.wavesurfer && env.AUTO_PLAY_AUDIO) {
                // Try to play the audio if auto-play is enabled
                currentMedia.wavesurfer.play().catch(e => console.log("Auto-play prevented by browser policy:", e));
            }
        }
        
        // Update which slides are visible for performance with better resource management
        function updateVisibleSlides(currentIndex) {
            const slides = galleryElement.children;
            
            for (let i = 0; i < slides.length; i++) {
                const slide = slides[i];
                if (Math.abs(i - currentIndex) <= env.PRELOAD_DISTANCE) {
                    // Show slides that are within preload distance
                    slide.style.display = 'flex';
                    
                    // For performance, only initialize audio when it becomes visible
                    if (mediaItems[i] && mediaItems[i].type === 'audio') {
                        // Only initialize if not already done
                        if (!mediaItems[i].wavesurfer) {
                            const vizContainer = document.getElementById(`audio-viz-${i}`);
                            if (vizContainer && vizContainer.children.length === 0) {
                                // Delay initialization slightly to prevent blocking
                                setTimeout(() => {
                                    initAudioVisualization(`audio-viz-${i}`, mediaItems[i].url, i);
                                }, 50);
                            }
                        } else {
                            // Ensure the visualization is visible if audio is loaded
                            const vizContainer = document.getElementById(`audio-viz-${i}`);
                            if (vizContainer && vizContainer.children.length === 0) {
                                initAudioVisualization(`audio-viz-${i}`, mediaItems[i].url, i);
                            }
                        }
                    }
                    
                    // For images, ensure they're loaded if they're close to view
                    if (mediaItems[i] && mediaItems[i].type === 'image') {
                        const imgElement = slide.querySelector('img');
                        if (imgElement && !imgElement.src) {
                            imgElement.src = mediaItems[i].url;
                        }
                    }
                    
                    // For videos, preload metadata if not currently playing
                    if (mediaItems[i] && mediaItems[i].type === 'video' && i !== currentIndex) {
                        const videoElement = slide.querySelector('video');
                        if (videoElement && videoElement.preload !== 'metadata') {
                            videoElement.preload = 'metadata';
                        }
                    }
                } else {
                    // Hide slides that are far from current position and potentially unload heavy resources
                    slide.style.display = 'none';
                    
                    // For audio slides that are far away, potentially unload to save memory
                    if (mediaItems[i] && mediaItems[i].type === 'audio' && mediaItems[i].wavesurfer) {
                        // Optionally destroy the wavesurfer instance to save memory for distant items
                        // Note: This is commented out as it might cause issues when navigating back
                        // mediaItems[i].wavesurfer.destroy();
                        // mediaItems[i].wavesurfer = null;
                    }
                    
                    // For videos, pause and set to lower preload level if far away
                    if (mediaItems[i] && mediaItems[i].type === 'video') {
                        const videoElement = slide.querySelector('video');
                        if (videoElement) {
                            videoElement.pause();
                            videoElement.preload = 'none';
                        }
                    }
                }
            }
        }
        
        // Enhanced performance: preload content before it's needed
        function preloadNearbyContent(currentIndex) {
            // Preload content in the next few positions to make transitions smoother
            const preloadRange = Math.min(3, env.PRELOAD_DISTANCE + 1); // Slightly more than display range
            
            for (let i = Math.max(0, currentIndex - preloadRange); 
                 i < Math.min(mediaItems.length, currentIndex + preloadRange + 1); i++) {
                if (mediaItems[i]) {
                    // Preload images by creating them off-screen
                    if (mediaItems[i].type === 'image' && !mediaItems[i].preloaded) {
                        const img = new Image();
                        img.src = mediaItems[i].url;
                        mediaItems[i].preloaded = true;
                    }
                    // Preload videos by setting preload attribute
                    else if (mediaItems[i].type === 'video' && !mediaItems[i].preloaded) {
                        mediaItems[i].preloaded = true;
                    }
                    // Preload audio by initiating wavesurfer when in range
                    else if (mediaItems[i].type === 'audio' && !mediaItems[i].preloaded) {
                        mediaItems[i].preloaded = true;
                    }
                }
            }
        }
        
        // Function to switch to a different seasonal layout
        function switchSeason(seasonName) {
            // Update the environment variable
            env.CURRENT_SEASON = seasonName;
            
            // Update all text content elements to use the new season
            const textElements = document.querySelectorAll('.text-content');
            textElements.forEach(element => {
                // Remove any existing season class
                element.classList.remove('season-1', 'season-2', 'season-3', 'season-4', 'season-5', 'season-6');
                // Add the new season class
                element.classList.add(seasonName);
            });
        }
        
        // Function to tag media items for archival purposes with additional metadata
        function tagMediaForArchive(index, tags, metadata = {}) {
            if (mediaItems[index]) {
                if (!mediaItems[index].archiveTags) {
                    mediaItems[index].archiveTags = [];
                }
                // Add new tags while avoiding duplicates
                const newTags = tags.filter(tag => !mediaItems[index].archiveTags.includes(tag));
                mediaItems[index].archiveTags = [...mediaItems[index].archiveTags, ...newTags];
                
                // Add metadata including text categorization if it's a text item
                if (!mediaItems[index].archiveMetadata) {
                    mediaItems[index].archiveMetadata = {};
                }
                Object.assign(mediaItems[index].archiveMetadata, metadata);
                
                // Update archive tracking
                if (window.galleryArchive) {
                    newTags.forEach(tag => {
                        window.galleryArchive.activeTags.add(tag);
                    });
                }
            }
        }
        
        // Enhanced tagging system with grouping capabilities
        function tagMediaItems(indices, tags, projectGroup = null) {
            if (!Array.isArray(indices)) {
                indices = [indices]; // Convert single index to array
            }
            
            indices.forEach(index => {
                if (index >= 0 && index < mediaItems.length) {
                    tagMediaForArchive(index, tags);
                    
                    // If project group is specified, add to that group
                    if (projectGroup) {
                        addToArchive(index, projectGroup, tags);
                    }
                }
            });
        }
        
        // Bulk tagging function for multiple items
        function bulkTagByCategory(category, tags, projectGroup = null) {
            mediaItems.forEach((item, index) => {
                if (item.textCategory === category) {
                    tagMediaForArchive(index, tags);
                    if (projectGroup) {
                        addToArchive(index, projectGroup, tags);
                    }
                }
            });
        }
        
        // Function to get media by multiple tags (AND operation)
        function getMediaByTags(tagArray) {
            if (!Array.isArray(tagArray) || tagArray.length === 0) return [];
            
            return mediaItems.filter(item => {
                if (!item.archivalMetadata || !item.archivalMetadata.tags) return false;
                
                // Check if item has ALL specified tags
                return tagArray.every(tag => item.archivalMetadata.tags.includes(tag));
            });
        }
        
        // Function to get media by any of the tags (OR operation)
        function getMediaByAnyTag(tagArray) {
            if (!Array.isArray(tagArray) || tagArray.length === 0) return [];
            
            return mediaItems.filter(item => {
                if (!item.archivalMetadata || !item.archivalMetadata.tags) return false;
                
                // Check if item has ANY of the specified tags
                return tagArray.some(tag => item.archivalMetadata.tags.includes(tag));
            });
        }
        
        // Function to create thematic collections based on tags
        function createThematicCollection(name, tags, description = '') {
            if (!window.galleryArchive) return false;
            
            if (!window.galleryArchive.thematicCollections) {
                window.galleryArchive.thematicCollections = {};
            }
            
            const collectionItems = getMediaByTags(tags);
            const itemIds = collectionItems.map(item => item.archivalMetadata.id);
            
            window.galleryArchive.thematicCollections[name] = {
                name,
                description,
                tags,
                items: itemIds,
                createdDate: new Date().toISOString(),
                itemCount: itemIds.length,
                layout: env.CURRENT_SEASON
            };
            
            return true;
        }
        
        // Function to get all media with a specific tag
        function getMediaByTag(tag) {
            if (!tag) return [];
            
            return mediaItems.filter(item => 
                item.archivalMetadata && 
                item.archivalMetadata.tags && 
                item.archivalMetadata.tags.includes(tag)
            );
        }
        
        // Function to suggest related items based on shared tags
        function getSuggestedRelatedItems(index, maxResults = 5) {
            if (index < 0 || index >= mediaItems.length) return [];
            
            const currentItem = mediaItems[index];
            if (!currentItem.archivalMetadata || !currentItem.archivalMetadata.tags) {
                return [];
            }
            
            const currentTags = currentItem.archivalMetadata.tags;
            const relatedItems = [];
            
            mediaItems.forEach((item, itemIndex) => {
                if (itemIndex === index) return; // Skip current item
                
                if (item.archivalMetadata && item.archivalMetadata.tags) {
                    // Count how many tags they share
                    const sharedTags = currentTags.filter(tag => 
                        item.archivalMetadata.tags.includes(tag)
                    ).length;
                    
                    if (sharedTags > 0) {
                        relatedItems.push({
                            index: itemIndex,
                            item,
                            sharedTagCount: sharedTags,
                            tags: item.archivalMetadata.tags
                        });
                    }
                }
            });
            
            // Sort by number of shared tags (descending)
            relatedItems.sort((a, b) => b.sharedTagCount - a.sharedTagCount);
            
            // Return top results
            return relatedItems.slice(0, maxResults);
        }
        
        // Function to add tags to a text content area dynamically
        function addTagsToTextElement(index, tags) {
            if (mediaItems[index] && textExtensions.includes(getFileExtension(mediaItems[index].filename))) {
                const textContainer = document.querySelector(`.media-item[data-index="${index}"] .text-content`);
                if (textContainer && tags && tags.length > 0) {
                    // Create a tags display element if it doesn't exist
                    let tagsElement = textContainer.querySelector('.content-tags');
                    if (!tagsElement) {
                        tagsElement = document.createElement('div');
                        tagsElement.className = 'content-tags';
                        tagsElement.style.cssText = `
                            position: absolute;
                            top: 10px;
                            right: 10px;
                            display: flex;
                            flex-wrap: wrap;
                            gap: 5px;
                            z-index: 10;
                        `;
                        textContainer.style.position = 'relative';
                        textContainer.appendChild(tagsElement);
                    }
                    
                    // Add each tag as a small pill
                    tags.forEach(tag => {
                        const tagSpan = document.createElement('span');
                        tagSpan.textContent = `#${tag}`;
                        tagSpan.style.cssText = `
                            background: rgba(255, 255, 255, 0.2);
                            color: white;
                            padding: 2px 8px;
                            border-radius: 10px;
                            font-size: 0.8rem;
                            cursor: pointer;
                        `;
                        tagSpan.addEventListener('click', () => {
                            // Maybe highlight other items with this tag
                            console.log(`Clicked tag: ${tag}`);
                        });
                        tagsElement.appendChild(tagSpan);
                    });
                }
            }
        }
        
        // Function to add background image to text content
        function addTextBackground(index, imageUrl) {
            if (mediaItems[index] && textExtensions.includes(getFileExtension(mediaItems[index].filename))) {
                const textContainer = document.querySelector(`.media-item[data-index="${index}"] .text-content`);
                if (textContainer) {
                    textContainer.style.backgroundImage = `url('${imageUrl}')`;
                    textContainer.style.backgroundSize = 'cover';
                    textContainer.style.backgroundPosition = 'center';
                    textContainer.style.backgroundBlendMode = 'multiply'; // Blend text with background
                }
            }
        }
        
        // Function to get media items by archive tags
        function getMediaByTag(tag) {
            return mediaItems.filter(item => item.archiveTags && item.archiveTags.includes(tag));
        }
        
        // Hidden archive functionality for future use
        function initializeArchiveSystem() {
            // Create an internal archive structure if enabled
            if (env.ENABLE_ARCHIVE_MODE) {
                // This would connect to an archive API in a real implementation
                console.log("Archive system initialized");
            }
            
            // Store initial layout state for potential archival
            window.galleryArchive = {
                layouts: {
                    'season-1': { name: 'Classic Zine', active: true, description: 'Traditional zine aesthetic with classic typography' },
                    'season-2': { name: 'Retro Futuristic', active: false, description: 'Synthwave and retro-futuristic visual elements' },
                    'season-3': { name: 'Minimalist', active: false, description: 'Clean, minimal design with ample whitespace' },
                    'season-4': { name: 'Cyberpunk', active: false, description: 'Neon-drenched cyberpunk aesthetic' }
                },
                textCategories: {
                    'maximalist': { name: 'Full Page Maximalist', count: 0, active: true, description: 'Large, impactful statements taking full page' },
                    'aphorisms': { name: 'Aphorisms & Ramblings', count: 0, active: true, description: 'Short quotes with alternating alignment' },
                    'article': { name: 'Structured Articles', count: 0, active: true, description: 'Formal article-style text content' },
                    'magazine': { name: 'Magazine Articles', count: 0, active: true, description: 'Magazine-style formatted text' },
                    'news': { name: 'News Articles', count: 0, active: true, description: 'Journalistic style content' },
                    'poem': { name: 'Poetry', count: 0, active: true, description: 'Verse content with line breaks preserved' },
                    'verse': { name: 'Verse & Rhyming', count: 0, active: true, description: 'Rhyming poetic content' },
                    'listicle': { name: 'Listicles & Lists', count: 0, active: true, description: 'List-based content' },
                    'caption': { name: 'Captions', count: 0, active: true, description: 'Brief descriptive text for media' },
                    'journal': { name: 'Personal Journal', count: 0, active: true, description: 'Diary-like personal entries' },
                    'social': { name: 'Social Media', count: 0, active: true, description: 'Social media style posts' },
                    'longform': { name: 'Long-form Content', count: 0, active: true, description: 'Extended text content' },
                    'standard': { name: 'Standard Text', count: 0, active: true, description: 'Regular unclassified text content' }
                },
                currentLayout: env.CURRENT_SEASON,
                mediaCollection: [...mediaItems], // Clone current media items
                projectGroups: {}, // Store media grouped by projects/seasons
                thematicCollections: {}, // Store collections based on tags/themes
                metadataHistory: {}, // Track changes to media metadata over time
                creationTimeline: [], // Track when content was added
                activeTags: new Set(), // Collection of all used tags
            };
            
            // Initialize creation timeline and project groups
            initializeArchiveMetadata();
        }
        
        // Initialize archive metadata for tracking
        function initializeArchiveMetadata() {
            // Add timestamp to all current media items
            const now = new Date().toISOString();
            
            mediaItems.forEach((item, index) => {
                if (!item.archivalMetadata) {
                    item.archivalMetadata = {
                        id: `item_${index}_${Date.now()}`,
                        addedDate: now,
                        lastAccessed: now,
                        originalSource: item.source,
                        format: getFileExtension(item.filename),
                        tags: [],
                        projectGroup: 'default', // Default project group
                        isArchived: false
                    };
                }
                
                // Add to timeline
                window.galleryArchive.creationTimeline.push({
                    id: item.archivalMetadata.id,
                    type: item.type,
                    date: now,
                    action: 'added'
                });
            });
            
            // Create default project group
            window.galleryArchive.projectGroups['default'] = {
                id: 'default',
                name: 'Default Collection',
                description: 'Initial collection of media items',
                items: mediaItems.map(item => item.archivalMetadata.id),
                createdDate: now,
                layout: env.CURRENT_SEASON
            };
        }
        
        // Archive management functions
        function addToArchive(itemIndex, projectGroup = null, tags = []) {
            if (itemIndex < 0 || itemIndex >= mediaItems.length) return false;
            
            const item = mediaItems[itemIndex];
            if (!item.archivalMetadata) {
                // Initialize if not already done
                const now = new Date().toISOString();
                item.archivalMetadata = {
                    id: `item_${itemIndex}_${Date.now()}`,
                    addedDate: now,
                    lastAccessed: now,
                    originalSource: item.source,
                    format: getFileExtension(item.filename),
                    tags: [],
                    projectGroup: projectGroup || 'default',
                    isArchived: true
                };
            }
            
            // Update or set project group
            if (projectGroup) {
                item.archivalMetadata.projectGroup = projectGroup;
                
                // Add to project group if it doesn't exist
                if (!window.galleryArchive.projectGroups[projectGroup]) {
                    window.galleryArchive.projectGroups[projectGroup] = {
                        id: projectGroup,
                        name: projectGroup,
                        description: `Collection: ${projectGroup}`,
                        items: [],
                        createdDate: new Date().toISOString(),
                        layout: env.CURRENT_SEASON
                    };
                }
                
                // Add item to project group
                if (!window.galleryArchive.projectGroups[projectGroup].items.includes(item.archivalMetadata.id)) {
                    window.galleryArchive.projectGroups[projectGroup].items.push(item.archivalMetadata.id);
                }
            }
            
            // Add tags
            if (tags && Array.isArray(tags)) {
                tags.forEach(tag => {
                    if (!item.archivalMetadata.tags.includes(tag)) {
                        item.archivalMetadata.tags.push(tag);
                        window.galleryArchive.activeTags.add(tag);
                    }
                });
            }
            
            // Add to timeline
            window.galleryArchive.creationTimeline.push({
                id: item.archivalMetadata.id,
                type: item.type,
                date: new Date().toISOString(),
                action: 'archived',
                projectGroup: projectGroup || 'default'
            });
            
            return true;
        }
        
        function getArchivedByProject(projectName) {
            const project = window.galleryArchive.projectGroups[projectName];
            if (!project) return [];
            
            return project.items.map(itemId => {
                return mediaItems.find(item => item.archivalMetadata && item.archivalMetadata.id === itemId);
            }).filter(item => item !== undefined);
        }
        
        function getArchivedByTag(tag) {
            return mediaItems.filter(item => 
                item.archivalMetadata && 
                item.archivalMetadata.tags && 
                item.archivalMetadata.tags.includes(tag)
            );
        }
        
        function getArchivedByLayout(layoutName) {
            return mediaItems.filter(item => 
                item.archivalMetadata && 
                item.archivalMetadata.layout === layoutName
            );
        }
        
        // Function to add background image to text content
        function addTextBackground(index, imageUrl) {
            if (mediaItems[index] && textExtensions.includes(getFileExtension(mediaItems[index].filename))) {
                const textContainer = document.querySelector(`.media-item[data-index="${index}"] .text-content`);
                if (textContainer) {
                    textContainer.style.backgroundImage = `url('${imageUrl}')`;
                    textContainer.style.backgroundSize = 'cover';
                    textContainer.style.backgroundPosition = 'center';
                    textContainer.style.backgroundBlendMode = 'multiply'; // Blend text with background
                }
            }
        }
        
        // Function to get media items by archive tags
        function getMediaByTag(tag) {
            return mediaItems.filter(item => item.archiveTags && item.archiveTags.includes(tag));
        }
        
        // Initialize the archive system when the gallery loads
        initializeArchiveSystem();
    </script>
</body>
</html>